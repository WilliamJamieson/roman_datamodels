from datetime import datetime
from pathlib import Path
from textwrap import dedent

from datamodel_code_generator.parser.base import Result
from datamodel_code_generator.reference import get_relative_path

from roman_datamodels.pydantic.parser import RadSchemaParser
from roman_datamodels.pydantic.parser._utils import class_name_from_module, get_rad_schema_path


def make_file_path(path: Path, name: tuple[str]) -> Path:
    file_path = path
    for sub_path in name[:-1]:
        file_path = file_path / sub_path
        file_path.mkdir(exist_ok=True)

    return file_path / name[-1]


def create_code(file: Result, version: str, use_timestamp: bool) -> str:
    header = (
        dedent(
            f"""
            # Generated by RAD using generator based on datamodel-code-generator
            #    source schema: {file.source}-{version}.yaml
            #    time stamp:    {datetime.now() if use_timestamp else 'VERSION CONTROLLED'}
            # DO NOT EDIT THIS FILE DIRECTLY!
            """
        ).strip()
        + "\n\n"
    )

    return header + file.body


def create_base_module(module_paths: dict[str, list[str]]) -> str:
    code = ""
    all_classes = []
    for package, modules in module_paths.items():
        module_name = f".{package}" if package else ""
        modules = sorted(modules)
        for module in modules:
            class_name = class_name_from_module(package, module)
            code += f"from {module_name}.{module} import {class_name}\n"
            all_classes.append(class_name)

    code += "\n"
    code += "__all__ = [\n"
    for class_name in all_classes:
        code += f'    "{class_name}",\n'
    code += "]\n"

    return code


def write_files(
    path: Path,
    result: dict[tuple[str], Result],
    version: str | None = None,
    use_timestamp: bool = True,
) -> None:
    version = version or "1.0.0"

    module_paths = {}
    for name, file in result.items():
        write_path = make_file_path(path, name)
        with write_path.open("w") as f:
            f.write(create_code(file, version, use_timestamp))

        module_path = get_relative_path(path, write_path)
        module_name = module_path.stem
        module_parent = module_path.parent.as_posix()
        module_parent = "" if module_parent == "." else module_parent

        if module_parent not in module_paths:
            module_paths[module_parent] = []

        if module_name != "__init__":
            module_paths[module_parent].append(module_name)

    with (path / "__init__.py").open("w") as f:
        f.write(create_base_module(module_paths))


def generate_files(
    write_path: Path,
    version: str | None = None,
    use_timestamp: bool = True,
):
    schema_path = get_rad_schema_path(version)
    parsed_results = RadSchemaParser(schema_path).parse()
    write_files(write_path, parsed_results, version, use_timestamp)


def setup_files():
    write_path = Path(__file__).parent / "_generated"
    write_path.mkdir(exist_ok=True)

    generate_files(write_path, use_timestamp=False)


if __name__ == "__main__":
    setup_files()
