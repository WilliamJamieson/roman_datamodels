from datetime import datetime
from pathlib import Path
from textwrap import dedent

from asdf.config import get_config
from datamodel_code_generator import DataModelType, PythonVersion
from datamodel_code_generator.model import get_data_model_types
from datamodel_code_generator.parser.base import Result
from datamodel_code_generator.reference import get_relative_path

from roman_datamodels.pydantic.parser import RadSchemaParser


def get_rad_schema_path(suffix: str) -> Path:
    manager = get_config().resource_manager

    for resource in manager._resource_mappings:
        if resource.package_name == "rad" and resource.delegate.uri_prefix.endswith(suffix):
            return resource.delegate.root


def create_rad_schema_parser(path: Path) -> RadSchemaParser:
    data_model_types = get_data_model_types(DataModelType.PydanticV2BaseModel, target_python_version=PythonVersion.PY_311)
    return RadSchemaParser(
        path,
        data_model_type=data_model_types.data_model,
        data_model_root_type=data_model_types.root_model,
        data_model_field_type=data_model_types.field_model,
        data_type_manager_type=data_model_types.data_type_manager,
        dump_resolve_reference_action=data_model_types.dump_resolve_reference_action,
        use_annotated=True,
        field_constraints=True,
        base_class="roman_datamodels.pydantic.datamodel.RomanDataModel",
        custom_template_dir=Path(__file__).parent / "parser" / "custom_templates",
        additional_imports=["typing.ClassVar"],
    )


def make_file_path(path: Path, name: tuple[str]) -> Path:
    file_path = path
    for sub_path in name[:-1]:
        file_path = file_path / sub_path
        file_path.mkdir(exist_ok=True)

    return file_path / name[-1]


def create_code(file: Result, version: str, use_timestamp: bool) -> str:
    header = (
        dedent(
            f"""
            # Generated by RAD using generator based on datamodel-code-generator
            #    source schema: {file.source}-{version}.yaml
            #    time stamp:    {datetime.now() if use_timestamp else 'VERSION CONTROLLED'}
            # DO NOT EDIT THIS FILE DIRECTLY!
            """
        ).strip()
        + "\n\n"
    )

    return header + file.body


def class_name_from_module(module: str, name: str):
    class_name = "".join([p.capitalize() for p in name.split("/")[-1].split("_")])
    if "reference_files" in module:
        class_name += "Ref"

    return class_name


def create_base_module(module_paths: dict[str, list[str]]) -> str:
    code = ""
    all_classes = []
    for module, names in module_paths.items():
        module_name = f".{module}" if module else ""
        names = sorted(names)
        for name in names:
            class_name = class_name_from_module(module, name)
            code += f"from {module_name}.{name} import {class_name}\n"
            all_classes.append(class_name)

    code += "\n"
    code += "__all__ = [\n"
    for class_name in all_classes:
        code += f'    "{class_name}",\n'
    code += "]\n"

    return code


def write_files(
    path: Path,
    result: dict[tuple[str], Result],
    version: str | None = None,
    use_timestamp: bool = True,
) -> None:
    version = version or "1.0.0"

    module_paths = {}
    for name, file in result.items():
        write_path = make_file_path(path, name)
        with write_path.open("w") as f:
            f.write(create_code(file, version, use_timestamp))

        module_path = get_relative_path(path, write_path)
        module_name = module_path.stem
        module_parent = module_path.parent.as_posix()
        module_parent = "" if module_parent == "." else module_parent

        if module_parent not in module_paths:
            module_paths[module_parent] = []

        if module_name != "__init__":
            module_paths[module_parent].append(module_name)

    with (path / "__init__.py").open("w") as f:
        f.write(create_base_module(module_paths))


def generate_files(
    suffix: str,
    write_path: Path,
    version: str | None = None,
    use_timestamp: bool = True,
):
    schema_path = get_rad_schema_path(suffix)
    parsed_results = create_rad_schema_parser(schema_path).parse()
    write_files(write_path, parsed_results, version, use_timestamp)


def setup_files():
    write_path = Path(__file__).parent / "_generated"
    write_path.mkdir(exist_ok=True)

    generate_files("schemas", write_path, use_timestamp=False)


if __name__ == "__main__":
    setup_files()
