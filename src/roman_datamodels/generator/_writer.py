"""
Handle writing the parser results to python files.
"""
__all__ = ["write_files"]

from datetime import datetime
from pathlib import Path
from textwrap import dedent

from datamodel_code_generator.parser.base import Result
from datamodel_code_generator.reference import get_relative_path

from ._utils import class_name_from_module


def write_files(
    path: Path,
    results: dict[tuple[str], Result],
    version: str | None = None,
    use_timestamp: bool = True,
) -> None:
    """
    Write the parser results to actual files.

    Parameters
    ----------
    path: Path
        The base path for where the files will be written.
    results: dict[tuple[str], Result]
        The results from the parser
    version: str, optional
        The version of the schemas being used.
    use_timestamp: bool, optional
        If we timestamp the output files.

    Effects
    -------
    Write the parser results to files.
    """
    # Set the version if it is not provided.
    #    this should be updated to "1.0" when bugfix versions are dropped from
    #    the naming of the schemas.
    version = version or "1.0.0"

    module_paths = {}  # so that we can fill in the __init__ modules
    for name, file in results.items():
        # Create the file path and then write the file to the path
        write_path = _make_file_path(path, name)
        with write_path.open("w") as f:
            f.write(_create_code(file, version, use_timestamp))

        # Add the module path data so we can turn it into __init__ modules
        module_path = get_relative_path(path, write_path)
        module_name = module_path.stem
        module_parent = module_path.parent.as_posix()
        module_parent = "" if module_parent == "." else module_parent

        if module_parent not in module_paths:
            module_paths[module_parent] = []

        if module_name != "__init__":
            module_paths[module_parent].append(module_name)

    # Write the __init__ modules
    _write_init(path, module_paths, version, use_timestamp)


def _create_code(file: Result, version: str, use_timestamp: bool) -> str:
    """
    Create the final form of the code from a parser result.

    Parameters
    ----------
    file: Result
        An output file from from the parser.
    version: str
        The version of the schemas being used.
    use_timestamp: bool
        If we timestamp the output file.

    Return
    ------
    Text to be written to the output file for the given parser result.
    """
    # Create the source schema
    source_schema = f"{file.source}-{version}.yaml" if file.source else "NONE"

    # Create the header to denote this file was generated and from what source
    header = (
        dedent(
            f"""
            # Generated by RAD using generator based on datamodel-code-generator
            #    source schema: {source_schema}
            #    time stamp:    {datetime.now() if use_timestamp else 'VERSION CONTROLLED'}
            # DO NOT EDIT THIS FILE DIRECTLY!
            """
        ).strip()
        + "\n\n"
    )

    return header + file.body


def _create_init_module(module_paths: dict[str, list[str]], version: str, use_timestamp: bool, suffix: str) -> str:
    """
    Create an __init__ for the given modules.

    Parameters
    ----------
    module_paths: dict[str, list[str]]
        A mapping of package names to lists of module names.
    version: str
        The version of the schemas being used. (this is a pass through to create_code)
    use_timestamp: bool
        The version of the schemas being used. (this is a pass through to create_code)
    suffix: str
        A suffix to add to the class names.

    Returns
    -------
    A string containing the __init__ module.
    """
    body = ""
    all_classes = []
    for package, modules in module_paths.items():
        # prefix with a dot if not the top level package
        module_name = f".{package}" if package else ""

        # Sort the modules so the output is consistent
        modules = sorted(modules)
        for module in modules:
            # Add an import statement for each data model class
            class_name = f"{class_name_from_module(package, module)}{suffix}"
            body += f"from {module_name}.{module} import {class_name}\n"
            all_classes.append(class_name)

    # Create the __all__ list
    body += "\n"
    body += "__all__ = [\n"
    for class_name in all_classes:
        body += f'    "{class_name}",\n'
    body += "]\n"

    return _create_code(Result(body=body, source=None), version, use_timestamp)


def _make_file_path(path: Path, name: tuple[str]) -> Path:
    """
    Make construct the file path and make sure the directories exist.

    Parameters
    ----------
    path: Path
        The base path for the file path.
    name: tuple[str]
        The name tuple from the parser result. This is a tuple of the import, i.e.
        ".".join(str(p) for p in name) is the import statement for the file relative
        to the package the files will be in.

    Returns
    -------
    The file path for the file.
    """
    file_path = path

    # The last value in the tuple is the file name, so we don't want to make a directory
    # for it.
    for sub_path in name[:-1]:
        file_path = file_path / sub_path

        # Make sure the directory exists
        file_path.mkdir(exist_ok=True)

    # The last value in the tuple is the file name, so add it on now.
    return file_path / name[-1]


def _write_init(
    path: Path, module_paths: dict[str, list[str]], version: str, use_timestamp: bool, suffix: str | None = None
) -> None:
    """
    Write the __init__ module for the given modules.

    Parameters
    ----------
    path: Path
        The base path for where the files will be written.
    module_paths: dict[str, list[str]]
        A mapping of package names to lists of module names.
    version: str
        The version of the schemas being used.
    use_timestamp: bool
        If we timestamp the output file.
    suffix: str, optional
        A suffix to add to the class names.

    Effects
    -------
    Write the __init__ module for the given modules.
    """
    suffix = suffix or ""

    # Write the top level __init__ module
    with (path / "__init__.py").open("w") as f:
        f.write(_create_init_module(module_paths, version, use_timestamp, suffix))

    # Write the __init__ modules for the sub packages
    del module_paths[""]  # remove the top level package
    for base_path, base_modules in module_paths.items():
        new_module_paths = {"": base_modules}  # Add all the new "top level" modules
        for path_, modules in module_paths.items():
            # Add all the sub-packages adjusted for the new relative import
            path_prefix = f"{base_path}."
            if path_.startswith(path_prefix):
                new_module_paths[path_.split(path_prefix)[-1]] = modules

        # Suffix preserves the module suffix has that is determined the base path and
        # so can be lost.
        new_suffix = class_name_from_module(base_path, "") if suffix == "" else suffix
        _write_init(path / base_path, new_module_paths, version, use_timestamp, new_suffix)
